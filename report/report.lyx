#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
\date{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 2cm
\rightmargin 1cm
\bottommargin 2cm
\secnumdepth -2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation 0bp
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
markboth{The Hebrew University of Jerusalem, March 2015}{}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Crushing Candy Crush - An AI Project
\end_layout

\begin_layout Author
Daniel Hadar & Oren Samuel
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this work, we propose several search methods in order to provide a solving
 meachnism for a general Match-3 game, such as Candy-Crush, in its simplest
 form.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
What are Match-3 Games?
\end_layout

\begin_layout Standard
On March 26th 2014, the mobile game development company King Digital Entertainme
nt became a publicly traded company, valued at over $7 Billion.
 Their most popular game (and the one that brought in most of their capital)
 was Candy Crush Saga, a Match-3 Puzzle video game, available for play on
 Facebook and on mobile platforms.
 This was another milestone in the evolution of Match-3 video games (a subset
 of the more general Tile Matching category of games), which finds its roots
 in the well-known Tetris (1985), goes through games like Yoshi’s Cookie
 (1992) and Bejewled (2001), and is still present today, as King Digital
 releases new levels for Candy Crush Saga on a weekly basis.
 Match-3 is family of single-player video games; The basic, common elements
 are a game board (usually square or rectangular in shape) and bricks of
 different types, arranged in a matrix formation on the board.
 In some games, the bricks change their location independently as time passes;
 in others, the bricks remain still until the player interferes.
 The types of moves a player can perform differ between games - moving,
 swapping and rotating of a single brick or a cluster of bricks all appear
 in some implementations of Match-3 games.
 The player’s goal, however, is mostly the same - to identify patterns in
 the bricks’ arrangement across the board, and create clusters of bricks
 of the same type.
 Creating a cluster makes it disappear from the board and awards the player
 with an amount of points proportional to the cluster’s size.
\end_layout

\begin_layout Subsection
The game at hand: GemGem
\end_layout

\begin_layout Standard
In order to to research the general Match-3 category of games, we used a
 basic open-source, 
\shape italic
pygame
\shape default
-based Candy Crush Saga clone called GemGem.
 The version presented here is a version we modified for the purpose of
 this paper; The original version can be found online.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://inventwithpython.com/blog/2011/06/24/new-game-source-code-gemgem-a-bejeweled-clone/"
target "http://inventwithpython.com/blog/2011/06/24/new-game-source-code-gemgem-a-bejeweled-clone/"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Subsubsection
Rules 
\end_layout

\begin_layout Standard
In GemGem, the basic setting is a square checkered board.
 Each cell in the board contains a 'gem' of a certain color.
 The board's side 
\emph on
size
\emph default
 and number of unique gems types can be configured by the player: board
 size can be set in the range 
\begin_inset Formula $4-8$
\end_inset

; the number of gems can be set in the range 
\begin_inset Formula $4-7$
\end_inset

.
 A player's move (
\shape italic
swap
\shape default
) consists of choosing two adjacent gems to switch between.
 We say that a swap is 
\shape italic
valid
\shape default
 if and only if it produces a board where there is at least one 
\shape italic
sequence
\shape default
 - a vertical or horizontal chain of 
\begin_inset Formula $3$
\end_inset

 or more consecutive gems of the same color.
 An invalid swap is not allowed.
 
\end_layout

\begin_layout Standard
Once a valid swap is performed, the following process is initiated:
\end_layout

\begin_layout Enumerate
The gems in the created sequence(s) are 
\shape italic
cleared
\shape default
, rendering their cells empty.
\end_layout

\begin_layout Enumerate
The gems which reside above the empty cells are pulled down in a gravitational
 manner, filling the empty cells.
 The fallen gems' original cells become empty.
\end_layout

\begin_layout Enumerate
New gems 
\shape italic
appear
\shape default
 (i.e “fall down”) in the now empty cells.
\end_layout

\begin_layout Enumerate
If the process creates new gem sequences, return to step 1.
 Otherwise, wait for the player's next swap.
\end_layout

\begin_layout Standard
This 
\begin_inset Quotes eld
\end_inset

chain reaction
\begin_inset Quotes erd
\end_inset

, i.e a series of 1 or more such iterations, is called a 
\shape italic
cascade
\shape default
.
 Once the the iteration process is finished, i.e there are no remaining sequences
 on the board, we say that the board is 
\shape italic
stable
\shape default
.
\end_layout

\begin_layout Standard
If there are no valid swaps on the board, we say that we've reached a 
\shape italic
game-over
\shape default
 state.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Subsubsection
Assumptions
\end_layout

\begin_layout Standard
Under the given rules, there are many ways one could interpret some aspects
 of the game's behaviour.
 We tried to be as straightforward as possible - the 
\shape italic
simplest
\shape default
 interpretation is also the 
\shape italic
best
\shape default
 interpretation.
 Utilizing this approach, the game behaves in 
\emph on
the
\emph default
 following manner:
\end_layout

\begin_layout Enumerate

\series bold
Clusters:
\series default
 If a swap creates a 
\shape italic
cluster 
\shape default
(i.e an arbitrary arrangement of consecutive same-colored gems), the board
 is only cleared of gems that form parts of actual sequences.
 Other gems in the cluster are kept on the board.
 That is in contrast to some Match-3 variants where a whole cluster is can
 be cleared from the board.
\end_layout

\begin_layout Enumerate

\series bold
Randomization of appearing gems: 
\series default
The appearing gems (that fill the empty spaces created by cleared sequences)
 are chosen uniformly at random.
 That is in disagreement with the original implementation of GemGem, which
 prevented from appearing gems to be identically-colored to their neighbors
 on the board.
 When the game is configured such that the number of gem types is small,
 this assumption might cause very long cascades; however, contradicting
 this assumption makes the game almost deterministic, which is an even more
 undesirable trait.
\end_layout

\begin_layout Enumerate

\series bold
Randomization of the initial board: 
\series default
Contrary to the previous assumption, the initialization of the board is
 not random.
 The board is initialized such that there are no sequences - so no 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 points are given to the player, and the playing field is leveled, so to
 speak, when starting a game.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Subsubsection
Scoring Method
\end_layout

\begin_layout Standard
A cascade awards the player 
\begin_inset Formula $x$
\end_inset

 points, where 
\begin_inset Formula $x$
\end_inset

 is equals the number of gems cleared during the cascade.
 For example........
\end_layout

\begin_layout Standard
############
\end_layout

\begin_layout Standard
#############
\end_layout

\begin_layout Standard
We emphasize that it's at least s points because of assumption 2 mentioned
 before - appearing gems are randomized, therefore they can make the cascade
 longer than one can predict, and clear more gems from the board.
\end_layout

\begin_layout Subsection
Problem Definition
\end_layout

\begin_layout Standard
Once the rules of the game are well-defined, we can take on the mission
 of defining the abstract problem that lies within the game.
\end_layout

\begin_layout Standard
There are many natural problems that arise with the given set of rules.
 We've concluded that, from an AI point of view, there are 3 problems that
 would be intersting to tacle:
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Given an 
\begin_inset Formula $s\times s$
\end_inset

 Match-3 board containg 
\begin_inset Formula $g$
\end_inset

 types of gems, try to:
\end_layout

\begin_layout Description
(P1) Minimize the number of swaps needed to reach a score of at least 
\begin_inset Formula $c$
\end_inset

,
\end_layout

\begin_layout Description
(P2) Maximize the score while performing at most 
\begin_inset Formula $k$
\end_inset

 moves, or
\end_layout

\begin_layout Description
(P3) Perform as many moves as possible without reaching a game-over state.
\end_layout

\begin_layout Standard
We've chosen to tacle P1; We will later describe possible modifications
 to our approach that could tacle P2 and P3.
\end_layout

\begin_layout Standard
The problem is interesting because of the complexity of predicting a large
 amount of possible future moves (similarly to chess-like games) - thus
 AI tools are expected to improve the results when compared to simpler algorithm
s and human subjects.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Subsubsection
NP Completeness
\end_layout

\begin_layout Standard
Two papers, both published in March 2014, took on proving that problems
 arising from Match-3 games are NP-Complete.
\end_layout

\begin_layout Standard
The first such paper, by Guala, Leucci and Natale, defines 5 such problems
 (denoted Q1 through Q5).
 The first of which (Q1) is formulated in the following manner: 
\shape italic
Is there a sequence of moves that allows the player to pop a specific gem?
 
\shape default
The authors then go on to prove that Q1 is NP-Complete.
 Then, Q2 through Q5 are proven to be NP-Complete by reduction to Q1.
 
\end_layout

\begin_layout Standard
Q3 is of special interest to us, and is formulated as such: 
\shape italic
Can the player get a score of at least x in less than k moves? 
\shape default
This problem is very similar to our problem (P1), and we can perform a simple
 decision-to-search reduction from Q3 to P1: If we are to minimize the number
 of swaps moves needed to achieve a score 
\begin_inset Formula $c$
\end_inset

, we can check whether 
\begin_inset Formula $c$
\end_inset

 is achievable within 
\begin_inset Formula $1$
\end_inset

 move; if not, check whether it's achievable within 2 moves, and so one.
 The first time we get a positive answer will give us the minimal number
 of moves needed to reach score 
\begin_inset Formula $c$
\end_inset

.
 This, if so, implies that P1 is indeed NP-Complete.
 In a very similar approach, we can show that P2 is NP-Complete.
 And, if we utilize Q5 from Guala's paper, we can show that P3 is NP-Complete
 as well.
 It is noteworthy that the second paper, by Walsh, shows that Q3 is NP-Complete,
 too, and does so by formulating a reduction to the 3-SAT problem.
\end_layout

\begin_layout Subsubsection
Setting the Parameters
\end_layout

\begin_layout Standard
In our tests, the board size 
\begin_inset Formula $s$
\end_inset

 is set to 
\begin_inset Formula $6$
\end_inset

 and the number of gem types 
\begin_inset Formula $g$
\end_inset

 is set to 
\begin_inset Formula $4$
\end_inset

.
 The target score 
\begin_inset Formula $c$
\end_inset

 is set to 
\begin_inset Formula $250$
\end_inset

.
 We took these decisions after running preliminary tests over all of the
 possible combinations 
\begin_inset Formula $\left(s,g\right)\in\left\{ 4,5,6,7,8\right\} \times\left\{ 4,5,6,7\right\} $
\end_inset

.
 Our analysis showed that when 
\begin_inset Formula $\nicefrac{s}{g}\leq1$
\end_inset

, the proportion of games reaching a premature game-over state (i.e ending
 before the target score is reached) was 
\begin_inset Formula $\sim\frac{1}{2}$
\end_inset

, and this proportion grows as 
\begin_inset Formula $\nicefrac{s}{g}$
\end_inset

 decreases.
 On the other hand, when 
\begin_inset Formula $\nicefrac{s}{g}$
\end_inset

 increases and approaches 
\begin_inset Formula $2$
\end_inset

, there are too many valid swaps on the board for our algorithms to have
 a reasonable runtime.
 Therefore, we concluded that 
\begin_inset Formula $s=6$
\end_inset

 and 
\begin_inset Formula $g=4$
\end_inset

 (i.e 
\begin_inset Formula $\nicefrac{s}{g}=1.5$
\end_inset

) is a good compromise - there's a relatively small chance to reach dead-ends
 (game-over states), while the number of valid swaps is small enough that
 we can run thpusands of games in a reasonable amount of time.
\end_layout

\begin_layout Standard
###############
\end_layout

\begin_layout Standard
###############
\end_layout

\begin_layout Standard
Add Graph of s/g
\end_layout

\begin_layout Section
Approach and Methods
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Section
Analysis
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Section
Future Research
\end_layout

\end_body
\end_document
